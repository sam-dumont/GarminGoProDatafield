// Code generated by protoc-gen-monkeyc. DO NOT EDIT.

import Toybox.Lang;

class RequestGetPresetStatus {
    public var registerPresetStatus as Array<ERPS>;
    public var unregisterPresetStatus as Array<ERPS>;
    public var useConstantSettingIds as Boolean;
    
    public function initialize() {
        registerPresetStatus = [];
        unregisterPresetStatus = [];
        useConstantSettingIds = false;
    }
    
    public function Encode() as ByteArray {
        var result = []b;
        {
            var packed = []b;
            for (var i = 0; i < registerPresetStatus.size(); i++) {
                packed.addAll(Protobuf.encodeFieldVarint(0, registerPresetStatus[i], true));
            }
            result.addAll(Protobuf.encodeFieldLen(1, packed, false));
        }
        {
            var packed = []b;
            for (var i = 0; i < unregisterPresetStatus.size(); i++) {
                packed.addAll(Protobuf.encodeFieldVarint(0, unregisterPresetStatus[i], true));
            }
            result.addAll(Protobuf.encodeFieldLen(2, packed, false));
        }
        result.addAll(Protobuf.encodeFieldVarint(3, useConstantSettingIds, false));
        return result;
    }
    
    public function Decode(input as ByteArray) as Void {
        var d = new Protobuf.Decoder(input);
        while (d.remaining() > 0) {
            var tag = d.varint32();
            switch (tag >> 3) {
                case 1: {
                    switch (tag & 7) {
                        case Protobuf.VARINT:
                            registerPresetStatus.add(d.varint32() as ERPS);
                            break;
                        case Protobuf.LEN:
                            for (var endRemaining = d.remaining() - d.varint32(); d.remaining() > endRemaining;) {
                                registerPresetStatus.add(d.varint32() as ERPS);
                            }
                            break;
                        default:
                            throw new Protobuf.Exception("invalid wire type");
                    }
                    break;
                }
                case 2: {
                    switch (tag & 7) {
                        case Protobuf.VARINT:
                            unregisterPresetStatus.add(d.varint32() as ERPS);
                            break;
                        case Protobuf.LEN:
                            for (var endRemaining = d.remaining() - d.varint32(); d.remaining() > endRemaining;) {
                                unregisterPresetStatus.add(d.varint32() as ERPS);
                            }
                            break;
                        default:
                            throw new Protobuf.Exception("invalid wire type");
                    }
                    break;
                }
                case 3: {
                    Protobuf.assertWireType(tag, Protobuf.VARINT);
                    useConstantSettingIds = d.varint32() != 0;
                    break;
                }
            }
        }
    }
    
    public function GetRegisterPresetStatus() as Array<ERPS> {
        return registerPresetStatus;
    }
    
    public function GetUnregisterPresetStatus() as Array<ERPS> {
        return unregisterPresetStatus;
    }
    
    public function GetUseConstantSettingIds() as Boolean {
        return useConstantSettingIds;
    }
}

enum ERPS {
    ERPS_P = 1,
    ERPS_PGA = 2,
}

var ERPSValue as Dictionary<ERPS, String> = {
    ERPS_P => "P",
    ERPS_PGA => "PGA",
} as Dictionary<ERPS, String>;
